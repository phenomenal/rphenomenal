.documentation
  %h1=@title
  
  %h2 Phenomenal
  The framework use Ruby meta programming facilities in order to adapt the behavior of the applications an add a 
  %acronym{:title=>"Domain specific language"}
    DSL
  \.
  This mean that any existing application can become Context Oriented simply by using 
  %tt require 'phenomenal'
  \.
  
  %h3 Architecture
  The following figure present the logical architecture of the framework
  #use_diagram.figure
    =display_phenomenal_use_diagram
    %p
      Use diagram
      
  %h4 Phenomenal::Manager
  %p
    Models the management of contexts, it includes the Singleton module in order to ensure that only one instance exist at any time.
    Contexts will register themselves and notify their states update to it so that it can decide wich adapation deploy and wich is the next adaptation 
    in the case of a 
    %tt phen_proceed 
    call.
    
    
  %h4  Phenomenal::Context
  %p
    Models a first class context with the different adaptations, it's activation age,...
    
  %h4  Phenomenal::Adaptation
  %p  
    Models a particular adaptation for a method in a particular context.
    
  %h4 Phenomenal::ConflictPolicies
  %p
    Implements the different conflict resolution policies, at this time: no resolution policy and age resolution policy.
    %br
    The user of the framework can easily add new conflict policies the following way:
  .snippet
    :coderay
      #!ruby
      module Phenomenal::ConflictPolicies
        # Priority based policy
        def priority_conflict_policy(adaptation1, adaptation2)
          adaptation1.context.priority <=> adaptation2.context.priority
        end
      end
    %p Conflict policies example

  %h4  Phenomenal::DSL
  %p
    Define the DSL for the framework.
    This is only syntactic sugar to simplify developers life.
  
  %h4  Phenomenal::Logger
  %p
    Handle exceptions raised in the framework and log them.
  
  %h4 Phenomenal::Error
  %p
    Models an exception for context errors.
  %h4  Proc
  %p
    The two methods are added to the 
    %tt Proc
    object to be able to bind proc's to classes and object at runtime to implement the proceed mechanism.
  
  %h2 Phenomenal Rails
  This step consists to find the best way to integrate our COP framework into rails applications.
  Best way means that we have to deal with the framework’s functionalities,
  the load of using this framework and the respect of the ‘Rails Way’.
  %h3 Framework integration
  #rails_tree
    .figure
      =image_tag("project/rails_tree_diagram.png") 
    %h4 Contexts directory structure
    We create a ‘contexts’ directory in the ‘app’ one of rails in order to contain all the context declaration files.
    For example ‘day_time’ is the directory that group all the contexts about day times.
    The file ‘afternoon.rb’ define the context afternoon (See 
    %strong Context declaration
    ) and the file
    'day_time' define the rules when the contexts in the directory are activated (See
    %strong Feature declaration
    ).
    %br
    In this example, we define four groups of contexts related to:
    #contexts_list
      %ul
        %li 
          Browsers: Chrome, Firefox, Internet Explorer, Safari
        %li 
          Day times: Morning, Afternoon, Evening, Night
        %li 
          Locations: Belgium, Unknown Country
        %li 
          Operating systems: Android, Ios, Linux, Macos, Windows

    %h4 Initialization
    The framework needs also to be loaded at the loading of the rails application.
    We add the file ‘contexts.rb’ in the initializers of rails.
    At this step, we also load all the contexts present in the ‘contexts’ directory and its sub-directories.
    In addition, this files allows the framework to work as well in the production or development environment.
    We also define the 
    %tt ActionDispatch::Callbacks.before
    method to fix the issue with the request repartitions of the rails server. Those problems are explained in
    details in the 
    %strong Issues occurred
    section.
    
    %h4 Middleware
    Finally, we add a 'middleware.rb' file in the lib directory in order to handle the context activation before
    calling the controller. In this class, we define the method
    %tt def self.activation_handler(env)
    that need to be adapted with the conditions in which we want to activate some context (see
    %strong Context activation
    ).
  .clear
  %h3 Context declaration
  .snippet
    :coderay
      #!ruby
      context :Firefox do 
        adaptations_for PagesHelper
        adapt :phenomenal_color do |r,g,b|
          proceed(r+50,g,b-100)
        end
        adapt :display_browser do 
          image_tag("contexts/browsers/firefox.png")
        end
        adapt :display_phenomenal_use_diagram do
          image_tag("project/phenomenal_use_diagram.svg")
        end
      end
    %p Firefox context declaration
  This class define the context
  %tt Firefox
  and its adaptations.
  %br
  Keywords usage:
  %ul
    %li
      %tt context:
      Define the context 
      %tt Firefox
      \. Like the classes in Ruby the contexts are open, so you can add adaptations at any point in your software.
    %li
      %tt adaptations_for:
      Until now to the next 
      %tt adaptations_for
      , all the following adaptations are defined
      for the class passed in parameter.
    %li
      %tt adapt:
      Adapt the method with name passed in parameter for the class defined by the previous 
      %tt adaptation_for
      \. 
      
  %h3 Feature declaration
  .snippet
    :coderay
      #!ruby
      feature :BrowsersSense do
        adaptations_for PhenomenalRails::Middleware
        adapt :activation_handler do |env|
          user_agent = env["HTTP_USER_AGENT"]
          if user_agent[/(Firefox)/]
            activate_context(:Firefox) 
          elsif user_agent[/(Chrome)/]
            activate_context(:Chrome) 
          elsif user_agent[/(Safari)/]
            activate_context(:Safari)
          elsif user_agent[/(MSIE)/]
            activate_context(:InternetExplorer) 
          end
          proceed(env)
        end
        activate_context(:BrowsersSense)
      end
    %p BrowserSense feature declaration
  %p
    To handle the activations of the contexts, we simply always adapt the 
    %tt activation_handler(env)
    method of the middleware. We have to use 
    %tt proceed(env)
    because all the features adapts this method to be activated.
  %h3 Issues occurred
  %h4 Classes caching
  Rails applications have different running environments; production and development.
  In the development one, at each refresh of the page, all the classes of the application are reloaded.
  We had a problem because when a class is loaded, a context of its name is defined, as the framework is
  not reloaded at each refresh, the context must not be redefined. So in the development environment, we force
  the deactivation and forget all the contexts before any actions of the controller.
  
  %h4 Requests dispatching
  The way in which rails handle is clients was also a problem. The rails server create a pool of processes
  an each request can be handle by a different one. As each request of the same client is handle by a
  random process, each one must be stateless. So, before all request all the contexts are deactivation
  and they are activated if needed.
