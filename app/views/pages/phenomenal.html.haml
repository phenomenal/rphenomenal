.documentation
  %h1=@title
  %h2 Phenomenal
  %h3 Domain Specific Language
  %h4 phen_context(*args,&block), alias: context
  %p
    Define a context with name passed in 
    %tt *args
    (if multiple name are passed then it will define a combined context).
    %br
    The content of the block will contain the relations and the adaptations of the context.
  %h5 adaptations_for(klass)
  %p 
    Define the class
    %tt klass
    on wich the next adaptation will be defined
  %h5 adapt(method,&block)
  %p
    Define an adapation for
    %tt method
    with 
    %tt block 
    as implementation on the class previously defined with
    %tt adaptations_for
  %h5 adapt_class(method,&block)
  %p
    Same as
    %tt adapt
    for class methods
  
  %h5 requires(context,*contexts)
  %p
    Define requirements for the current context
  %h5 suggests(context,*contexts)
  %p Define suggestions for the current context
  %h5 implies(context,*contexts)
  %p Define implications for the current context
    
  %h4 phen_feature(*args,&block), alias: feature
  %p
    Define a feature (a context handling relationships between contexts).
  %h5 requirements_for(source,targets)
  %p 
    Define a requirement from
    %tt source
    to
    %tt target
    contexts only defined when the feature is active
  
  %h5 implications_for(source,targets)
  %p 
    Define a implication from
    %tt source
    to
    %tt target
    contexts only defined when the feature is active
  
  %h5 suggestions_for(source,targets) 
  %p 
    Define a suggestion from
    %tt source
    to
    %tt target
    contexts only defined when the feature is active
  
  %h4 phen_forget_context(context)
  %p
    Remove tottaly a context from the system (must be inactive before). 
    
  %h4 phen_add_adaptation(context,klass, method_name, &implementation)
  %p
    Add an adaptation to a context for class 
    %tt klass
    and instance method
    %tt method_name
    with the block as implementation.
    
  %h4 phen_add_class_adaptation(context,klass, method_name, &implementation)
  %p
    Same as phen_add_adaptation but for class methods

  %h4 phen_remove_adaptation(context,klass,method_name) 
  %p 
    Remove an adaptation from 
    %tt context
    for the instance method 
    %tt method_name
    in class
    %tt klass.
  
  %h4 phen_remove_class_adaptation(context,klass,method_name) 
  %p 
    Same ad phen_remove adaptation but for class methods

  %h4 phen_activate_context(context), alias: activate_context
  %p
    Activate a context, this will deploy it's adaptations and trigger it's relationships
    
  %h4 phen_deactivate_context(context), alias: deactivate_context
  %p
    Deactivate a context (the context will became inactive only if as many deactivations has been performed than the number of activations.

  %h4 phen_context_active?(context)
  %p
    Return 
    %tt true 
    if 
    %tt context
    is active

  %h4 phen_context_informations(context)
  Return a hash with the useful informations concerning the 
  %tt context:
  %ul
    %li Name
    %li List of the adaptations
    %li Active state
    %li Activation age
    %li Activation count
    %li Type of context: Context or Feature

  %h4 phen_default_context
  %p
    Return the default context (containing the default adaptations of the methods).

  %h4 phen_defined_contexts    
  %p
    Return the list of defined contexts (the ones registered in the manager).

  %h4 phen_proceed(*args,&block), alias: proceed
  %p
    Call the underneath adaptation for the method calling this one.
    The adaptation that will be called depends of the conflict resolution policy.

  %h4 phen_change_conflict_policy(&block)
  %p
    Allow to change the conflict resolution policy used by 
    %tt Phenomenal::Manager
    \.
  .snippet
    :coderay
      #!ruby
      phen_change_conflict_policy { |a,b| no_resolution_conflict_policy(a,b) }
    %p Setting no resolution conflict policy
    
  %h4 requirements_for(source,targets)
  %p 
    Define a global requirement from
    %tt source
    to
    %tt target
    contexts
  
  %h4 implications_for(source,targets)
  %p 
    Define a global implication from
    %tt source
    to
    %tt target
    contexts
  
  %h4 suggestions_for(source,targets) 
  %p 
    Define a global suggestion from
    %tt source
    to
    %tt target
    contexts
  
  %h4 phen_graphical_view(file)
  %p 
    Generate a graphical representation of the system (red contexts are active ones)
    .snippet
      =image_tag "documentation/graphical_view.png"
    
  
  %h4 phen_textual_view
  %p Produce a textual representation of the system on STDOUT
  .snippet
    :coderay
      #!text
      Default context 
      Feature: Default context 
        c1 -> c2 
        c1 -> c3 
        c2 =< c3 
        f2 => f1 
      Context: c1 
      Context: c2 
      Context: c3 
      Feature: f1 
        c1 =< c2 
      Context: [f1, c1] 
      Context: [f1, c3] 
      Feature: f2 

    

